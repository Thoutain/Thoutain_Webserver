# webserver更新

## 功能
* 利用单例模式与阻塞队列实现异步的日志系统。记录服务器运行状态 blockqueue.h




阻塞、非阻塞
* 数据就绪阶段、第一阶段：根据系统IO操作的就绪状态   数据有没有到达  看tcp缓冲区有没有数据判断
  * 阻塞：调用IO方法的线程进入阻塞状态
  * 非阻塞：不会改变线程的状态，通过返回值判断  非阻塞需要设置一下文件描述符非阻塞  获取flag并改变  阻塞是不用判断返回值的
    * -1出错了  eintr（被信号中断）  eagain  ewouldblock（没读到数据）
    * 0读到数据的末尾，对方连接关闭  
    * >0读取到了多少数据
  * IO
    * 输入输出
    * 磁盘IO
    * tcp的读缓冲、写缓冲
    * 网络IO

* 同步、异步  数据读写阶段  第二阶段
  * 同步：内核区tcp缓冲区里面的数据需要我们一点点的搬到应用区我们定义的数组里
    * int size = recv(sockfd, buf, 1024, 0);
    * 同步需要消耗掉用户的时间
  * 异步是直接装到我们的数组里面  消耗的是内核的时间
    * 不消耗用户的时间，系统操作完成  完成之后通知我就行了
    * 异步IO接口
    * sigio信号
    * aio_read()
    * aio_write()
  * 有点类似于线上购票和线下购票的区别
  * 同步效率没有异步高  但是编程简单
  * 在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO

## SUMMERY

一个典型的网络IO接口调用，分为两个阶段，分别是数据就绪和数据读写，就绪阶段有阻塞与非阻塞，读写阶段有同步与异步

阻塞表现为直接返回，非阻塞就是一直循环……

同步是要消耗用户的时间，异步是系统全部帮你做完，且完成后通知你

* 同步需要自己从缓冲区一点一点的弄到你自己准备的buf里
* 阻塞\非阻塞与同步\异步是没有关系的
* 线程同步讲的是保证临界去的安全
  * a线程执行的时候b线程只能在外面等着



#### 五种IO模型

* 阻塞  不能做其他的事情  不过期间不会消耗资源
* 非阻塞  系统调用多了  消耗的资源多了  非阻塞忙轮询
* IO复用  让我们在一个进程中检测多个客户端是否有数据到达
  * 内核去检测  用二进制位去表示
  * 将多个read弄成一个select、poll、epoll这种
  * 他用的时候也会使进程阻塞，但是他可以同时阻塞多个IO操作
  * 话是同步的  只有调用了异步接口才会是异步
* 信号驱动
  * 等待数据
  * 处理数据
* 异步
  * 调用异步IO接口 



## http协议

* 请求报文
  * 请求首行
  * 请求头
  * 请求空行
  * 请求体
* 请求方法
* 状态码



#### 事件处理模式

IO事件、信号以及定时事件

同步IO常用于reactor模式  异步IO常用于proactor模式



#### C++11

explicit

default



#### 基础API

pthread_cond_init()

pthread_cond_destory()

pthread_cond_broadcast()

pthread_cond_wait() 

* 用于等待目标条件变量。该函数调用时需要传入 **mutex参数(加锁的互斥锁)** ，函数执行时，先把调用线程放入条件变量的请求队列，然后将互斥锁mutex解锁，当函数成功返回为0时，表示重新抢到了互斥锁，互斥锁会再次被锁上， **也就是说函数内部会有一次解锁和加锁操作**.   他会阻塞，所以要解锁

使用前要加锁

* 多线程访问，为了避免资源竞争，所以要加锁，使得每个线程互斥的访问公有资源。

pthread_cond_wait内部为什么要解锁

* 如果while或者if判断的时候，满足执行条件，线程便会调用pthread_cond_wait阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源。
* 具体到pthread_cond_wait的内部实现，当pthread_cond_wait被调用线程阻塞的时候，pthread_cond_wait会自动释放互斥锁。

#### 生产者消费者模型

* 一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用pthread_cond_signal发送一个资源可用信号。
* 在wait成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait返回后，资源可能已经被使用了
* 再具体点，有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用，但是有A，B两个线程都在等待，B比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，之后A获得互斥锁，但A回去发现资源已经被使用了，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么继续等待下去的条件就是使用while，要不然使用if的话pthread_cond_wait返回后，就会顺序执行下去。
* 生产者和消费者是互斥关系，两者对缓冲区访问互斥，同时生产者和消费者又是一个相互协作与同步的关系，只有生产者生产之后，消费者才能消费。

#### 阻塞队列

* 阻塞队列类中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者。
* 阻塞队列中，使用了循环数组实现了队列，作为两者共享缓冲区，当然了，队列也可以使用STL中的queue。

#### 日志分级

* debug
* warn
* info
* error
* fatal

#### fflush

* fflush()会强迫将缓冲区内的数据写回参数stream 指定的文件中，如果参数stream 为NULL，fflush()会将所有打开的文件数据更新。
* 在使用多个输出函数连续进行多次输出到控制台时，有可能下一个数据再上一个数据还没输出完毕，还在输出缓冲区中时，下一个printf就把另一个数据加入输出缓冲区，结果冲掉了原来的数据，出现输出错误。
* 在prinf()后加上fflush(stdout); 强制马上输出到控制台，可以避免出现上述错误。

#### 流程

* 日志文件
  * 局部变量的懒汉模式获取实例
  * 生成日志文件
* 同步
  * 判断是否分文件
  * 直接格式化输出内容
* 异步
  * 判断是否分文件
  * 格式化输出内容，将聂荣写入阻塞队列，创建一个写线程，从阻塞队列去除内容写入日志文件

#### RAII

* 智能指针
* RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.
* 在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定
* RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子

#### 线程池

\#include <pthread.h>
2int pthread_create (pthread_t *thread_tid,         //返回新生成的线程的id
3          					      const pthread_attr_t *attr,     //指向线程属性的指针,通常设置为NULL
4          				          void * (*start_routine) (void *),  //处理线程函数的地址    注意类型匹配问题  静态成员函数
5          						  void *arg);             //start_routine()中的参数
